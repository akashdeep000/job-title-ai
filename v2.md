# Project: Resilient Job Title Classification Engine

**Objective:** To build a robust, fault-tolerant application that classifies job titles from a CSV file using the Gemini API. The system will use a SQLite database to manage state, allowing it to be paused, restarted, and to retry failed requests gracefully.

---

### Phase 1: Project Initialization & Core Dependencies

1.  **Initialize Node.js Project:**
    *   Create a new directory for the project.
    *   Run `pnpm init` to create a `package.json` file.
    *   Set `"type": "module"` in `package.json`.

2.  **Install Dependencies:**
    *   **Core & Build Tools:** `typescript`, `@types/node`
    *   **Database (Drizzle ORM):** `drizzle-orm`, `better-sqlite3`
    *   **Database Migrations:** `drizzle-kit`, `tsx`
    *   **AI:** `@google/generative-ai`
    *   **CLI & UI:** `yargs`, `@types/yargs`, `ink`, `react`, `@types/react`
    *   **Utilities:** `fast-csv`, `p-limit`

3.  **Setup TypeScript:**
    *   Create a `tsconfig.json` file with modern settings, including:
        *   `"target": "ESNext"`
        *   `"module": "ESNext"`
        *   `"moduleResolution": "node"`
        *   `"jsx": "react-jsx"`
        *   `"outDir": "./dist"`
        *   `"strict": true`

4.  **Create Directory Structure:**
    ```
    /
    ├── src/
    │   ├── db/
    │   │   ├── schema.ts
    │   │   └── migrate.ts
    │   ├── utils/
    │   │   ├── ai.ts
    │   │   └── processor.ts
    │   ├── components/
    │   │   ├── App.tsx
    │   │   ├── ProgressBar.tsx
    │   │   └── Status.tsx
    │   └── cli.tsx
    ├── .env
    ├── .gitignore
    ├── drizzle.config.ts
    ├── package.json
    └── tsconfig.json
    ```

---

### Phase 2: Database Setup with Drizzle

1.  **Define Database Schema (`src/db/schema.ts`):**
    *   Create a `jobTitles` table schema.
    *   **Columns:**
        *   `id`: Integer, Primary Key, Autoincrement.
        *   `sourceId`: Text, from the original CSV `id` column.
        *   `jobTitle`: Text, Nullable.
        *   `status`: Text, Enum ('pending', 'processing', 'completed', 'failed'), Default: 'pending'.
        *   `retryCount`: Integer, Default: 0.
        *   `jobFunction`: Text, Nullable.
        *   `jobSeniority`: Text, Nullable.
        *   `confidence`: Real, Nullable.
        *   `standardizedJobTitle`: Text, Nullable.
        *   `createdAt`: Text, Timestamp, Default: Current Time.
        *   `updatedAt`: Text, Timestamp, For tracking updates.

2.  **Configure Drizzle (`drizzle.config.ts`):**
    *   Set up the configuration to point to the schema file (`src/db/schema.ts`).
    *   Define the output directory for migrations (`./drizzle`).
    *   Specify the SQLite database file (e.g., `./local.db`).
    *   Use the `drizzle-kit/driver/better-sqlite` driver.

3.  **Create Migration Script (`src/db/migrate.ts`):**
    *   Write a script that uses `drizzle-orm/better-sqlite3/migrator` to apply pending migrations to the database.

4.  **Add `package.json` Scripts:**
    *   `"db:generate": "drizzle-kit generate"`
    *   `"db:migrate": "tsx src/db/migrate.ts"`
    *   `"db:studio": "drizzle-kit studio"`

---

### Phase 3: CLI Commands & Core Logic

1.  **Refactor `src/cli.tsx`:**
    *   Use `yargs` to define a command-based structure.
    *   **`ingest <file>`:** Command to import data from a CSV.
    *   **`process`:** Command to start the AI processing worker.
    *   **`export <file>`:** Command to export processed data to a CSV.
    *   **`reset`:** (Optional but recommended) Command to clear the database.

2.  **Implement `ingest` Command Logic:**
    *   Use `fast-csv` to stream the input CSV file.
    *   For each row, create a new entry in the `jobTitles` table with `status: 'pending'`.
    *   Show progress using an Ink component.

3.  **Implement `process` Command Logic (`src/utils/processor.ts`):**
    *   Create a main processing loop.
    *   **Batch Selection:**
        *   Query the database for a batch of rows where `status` is `'pending'` OR (`status` is `'failed'` AND `retryCount` < `MAX_RETRIES`).
        *   Use `FOR UPDATE` or a similar transaction lock to prevent race conditions.
    *   **State Locking:** Update the status of the selected rows to `'processing'`.
    *   **AI Interaction (`src/utils/ai.ts`):**
        *   Reuse the existing `classifyJobTitles` function.
        *   Pass the batch of job titles to the Gemini API.
    *   **Handle Success:**
        *   On a successful API response, iterate through the results.
        *   Update the corresponding row in the database with the AI-generated data (`jobFunction`, `jobSeniority`, etc.).
        *   Set the row's `status` to `'completed'`.
    *   **Handle Failure:**
        *   If the API call fails or returns invalid data, update the rows' `status` to `'failed'` and increment `retryCount`.
    *   **Rate Limiting:** Implement a rate limiter to respect API usage quotas.
    *   **UI:** Display real-time progress and statistics.

4.  **Implement `export` Command Logic:**
    *   Query the database for all rows where `status` is `'completed'`.
    *   Use `fast-csv` to write the data to the specified output CSV file.

---

### Phase 4: User Interface with Ink

1.  **Main Component (`src/components/App.tsx`):**
    *   Acts as a router, rendering different UI components based on the executed `yargs` command.

2.  **Status Component (`src/components/Status.tsx`):**
    *   Periodically queries the database to fetch counts of jobs by status (Total, Pending, Completed, Failed).
    *   Displays these statistics in a clean, readable format.

3.  **Progress Bar Component (`src/components/ProgressBar.tsx`):**
    *   Receives `current` and `total` props.
    *   Renders a visual progress bar for long-running operations like `ingest`, `process`, and `export`.